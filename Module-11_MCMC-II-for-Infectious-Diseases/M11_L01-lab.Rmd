---
title: 'Module 11: Lesson 1 Lab'
author: "Callum Arnold"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  pdf_document:
    latex_engine: xelatex
    toc: true
    toc_depth: 4
header-includes:
  - \usepackage{cancel}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Background

## Preliminaries

In the first lecture we introduced the concept of simulation by which we meant
the procedure of *producing a realisation of the model*, or in other words a
possible outcome. In this lab session we will be modifying existing R functions
and by the end of this session, among other things, we will

-   draw samples from the distributions of the *final size* and the *duration*
    of the epidemic (see below for definitions of these quantities);

-   be able to simulate from an epidemic model where the infectious period
    follows a Weibull distribution;

-   be able to simulate from a stochastic Susceptible-Exposed-Infective-Removed
    (SEIR) epidemic model.

Start by downloading the file `simulation.R` from
[here](https://www.maths.nottingham.ac.uk/plp/pmztk/files/MCMC2-Seattle/labs-R-code/1/simulation.R)
and save it in your workspace. This file `simulation.R` contains four different
functions which will enable us to simulate realisations from various stochastic
epidemic models:

-   `simSIR.Markov`: The function produces realisations from a Markovian SIR
    model with infection and removal rate, $Œ≤/N$ and $Œ≥$ respectively. The
    procedure (as described in Section 2 in the lecture) is the following:

    -   first simulate the *time to the next event* and then

    -   decide the *type of the event* (infection or removal).

-   `simSIR.Markov.alternative`: This function also produces realisations from a
    Markovian SIR model with infection and removal rate, $Œ≤/N$ and $Œ≥$
    respectively but with a slightly different algorithm to the one described
    above. The procedure here is as follows:

    -   generate a possible time to the next infection and the possible time to
        the next removal; then

    -   the event which happens first determines the type of the next event.

-   `simSIR.Non.Markov.constant` and `simSIR.Non.Markov.gamma`: These two
    functions allows us to simulate realisations from non-Markov SIR models;
    with constant and Gamma infectious period respectively. The procedure is
    similar to the one used in `simSIR.Markov.alternative` based on Section 5 in
    Lecture 1.

## Definitions

In this section we give definitions of two quantities for which samples from
their distribution will be drawn.

### The threshold parameter $R_0$

An appealing feature of an epidemic model is that it embodies a threshold
parameter which can be utilised as a severity measure of the outbreak.
Stochastic models such as epidemics and branching processes typically generate
bimodal realisations where an epidemic may or may not die out quickly, depending
on the value of a threshold parameter R0 often referred to as the basic
reproduction number.This is the most important parameter in epidemic theory and
it is defined as *the expected number of infections generated by a typical
infective in an infinite susceptible population*.In the case of a homogeneously
mixing stochastic epidemic, it holds that $R0=Œ≤ùîº[I]$ where $ùîº[I]$ denotes the
expected infectious period. For instance, in the case of the Markovian SIR
model, $R0=Œ≤Œ≥$, since the individuals remain infectious for an average period of
length $1/Œ≥$.

### The final size of an epidemic

The final size of an epidemic is the total number of initial susceptibles who
contracted the disease by the end of the outbreak.

### The duration of the epidemic

Another quantity of interest is the duration of the epidemic and this is defined
as the *time that elapsed from the initial infection until the time of the last
removal*.

# Exercises

## Exercise 1

### Question

Go through the lines of each function and make sure that you follow the logic
behind.

### Answer

#### SIR Markov

```{r}
simSIR.Markov <- function(N, beta, gamma) {

  # initial number of infectives and susceptibles;
  I <- 1
  S <- N-1;

  # recording time;
  t <- 0;
  times <- c(t);

  # a vector which records the type of event (1=infection, 2=removal)
  type <- c(1);

  while (I > 0) {

    # time to next event;
    t <- t + rexp(1, (beta/N)*I*S + gamma*I);
    times <- append(times, t);
    
    if (runif(1) < beta*S/(beta*S + N*gamma)) {
      # infection
      I <- I+1;
      S <- S-1;
      type <- append(type, 1);
    }
    else {
      #removal
      I <- I-1
      type <- append(type, 2);
    }
  }
  
  # record the final size , i.e. the number of initially susceptlbles who 
  # contracted the disease sometime during the epidemic.
  #
  #
  #
  
  # record the times of events (infections/removals) as well as the type
  res <- list("t"=times, "type"=type);
  res
}
```

#### SIR Markov alt

```{r}
simSIR.Markov.alternative <- function(N, beta, gamma) {

  # initial number of infectives and susceptibles;
  I <- 1
  S <- N-1;

  # recording time;
  t <- 0;
  times <- c(t);

  # a vector which records the type of event (1=infection, 2=removal)
  type <- c(1);

  while (I > 0) {

    ############################################
    # simulate times to the next possible events
    ############################################
    
    # time to next infection
    if (S > 0) {
      t.next.infection <- t +  rexp(1, (beta/N)*I*S)
    }
    else {
      t.next.infection <- Inf;
    }
    
    # time to next removal    
    t.next.removal <- t + rexp(1, gamma*I)


    # check which of the two events happens first
    if (t.next.infection < t.next.removal) {
      # infection occurs
      I <- I+1;
      S <- S-1;
      type <- append(type, 1);
      times <- append(times, t.next.infection);
      t <- t.next.infection
    }
    else {
      #removal occurs
      I <- I-1
      times <- append(times, t.next.removal);
      type <- append(type, 2);
      t <- t.next.removal
    }
  }
  
  # record the final size , i.e. the number of initially susceptlbles who
  # contracted the disease sometime during the epidemic.
  #
  #
  
  # record the times of events (infections/removals) as well as the type
  #
  #
  res <- list("t"=times, "type"=type);
  res
}
```

#### SIR non-Markov constant

```{r}
simSIR.Non.Markov.constant <- function(N, beta, k) {

  # initial number of infectives and susceptibles;
  I <- 1
  S <- N-1;

  # recording time;
  t <- 0;
  times <- c(t);

  # create a vector containing the removal times of all the current infectives
  r <- k 

  # a vector which records the type of event (1=infection, 2=removal)
  type <- c(1);
  
  # a counter for labelling the individuals
  lambda <- 1;

  # a vector to store the labels
  labels <- c(1);

  while (I > 0) {

    ############################################
    # simulate times to the next possible events
    ############################################
    
    # time to next infection
    if (S > 0) {
      T  <- rexp(1, (beta/N)*I*S)
    }
    else {
      T <- Inf;
    }

    # time to next removal
    R <- min(r, na.rm=TRUE);
    
    # check which of the two events happens first
    if (t + T < R) {
      # infection occurs
      I <- I+1;
      S <- S-1;
      r <- append(r, t + T + k)
      type <- append(type, 1);
      times <- append(times, t + T);

      lambda <- lambda + 1;
      labels <- append(labels, lambda)
      t <- t + T
    }
    else {
      #removal occurs
      I <- I-1
      type <- append(type, 2);
      index.min.r <- which(min(r, na.rm=TRUE)==r)
      r[index.min.r] <- NA
      labels <- append(labels, index.min.r)
      times <- append(times, R);
      t <- R

      # update the vector of 
    }
  }
  
  # record the final size , i.e. the number of initially susceptlbles who contracted the disease sometime during the epidemic.
  #
  #
  
  # record the times of events (infections/removals) as well as the type
  #
  #
  res <- list("t"=times, "type"=type, "labels" = labels);
  res
}
```

#### SIR non-Markov Gamma

```{r}
simSIR.Non.Markov.gamma <- function(N, beta, gamma, delta) {

  # initial number of infectives and susceptibles;
  I <- 1
  S <- N-1;

  # recording time;
  t <- 0;
  times <- c(t);

  # create a vector containing the removal times of all the current infectives.
  k <- rgamma(1, gamma, delta)
  r <- k 

  # a vector which records the type of event (1=infection, 2=removal)
  type <- c(1);

  # a counter for labelling the individuals
  lambda <- 1;
  
  # a vector to store the labels
  labels <- c(1);

  while (I > 0) {

    ############################################
    # simulate times to the next possible events
    ############################################
    
    # time to next infection
    if (S > 0) {
      T  <- rexp(1, (beta/N)*I*S)
    }
    else {
      T <- Inf;
    }

    # time to next removal
    R <- min(r, na.rm=TRUE);
    
    # check which of the two events happens first
    if (t + T < R) {
      # infection occurs
      I <- I+1;
      S <- S-1;
      k <- rgamma(1, gamma, delta)
      r <- append(r, t + T + k)

      lambda <- lambda + 1;
      labels <- append(labels, lambda)
      type <- append(type, 1);
      times <- append(times, t + T);
      t <- t + T
    }
    else {
      #removal occurs
      I <- I-1
      type <- append(type, 2);
      index.min.r <- which(min(r, na.rm=TRUE)==r)
      r[index.min.r] <- NA
      labels <- append(labels, index.min.r)
      times <- append(times, R);
      t <- R      
    }
  }
  
  # record the final size , i.e. the number of initially susceptlbles who contracted the disease sometime during the epidemic.
  #
  #
  
  # record the times of events (infections/removals) as well as the type
  #
  #
  res <- list("t"=times, "type"=type, "labels"=labels);
  res
}
```

## Exercise 2

### Question

Simulate realisations from a Markovian SIR using the function `simSIR.Markov`
and make sure that you understand the output. You may assume that size of the
population size is N=21 (i.e. 20 susceptibles and 1 initial infective). In
addition, you could try different values for (Œ≤,Œ≥), e.g. (0.9,1),(2,1) and
(4,1).

### Answer

```{r}
simSIR.Markov(N=21, beta = 0.9, gamma = 1)
```

```{r}
library(purrr)
map2(
  .x = c(0.9, 2, 4),
  .y = c(1, 1, 1),
  .f = function(.x, .y){
    print(glue::glue("Beta = {.x}, Gamma = {.y}"))
    simSIR.Markov(N = 21, beta = .x, gamma = .y)
  }
)
```

## Exercise 3

### Question

Modify the existing functions in `simulation.R` to record the *final size* and
the *duration* of the epidemic as part of the functions' output.

### Answer

#### SIR Markov

```{r}
simSIR.Markov <- function(N, beta, gamma) {

  # initial number of infectives and susceptibles;
  I <- 1
  S <- N-1;

  # recording time;
  t <- 0;
  times <- c(t);

  # a vector which records the type of event (1=infection, 2=removal)
  type <- c(1);

  while (I > 0) {

    # time to next event;
    t <- t + rexp(1, (beta/N)*I*S + gamma*I);
    times <- append(times, t);
    
    if (runif(1) < beta*S/(beta*S + N*gamma)) {
      # infection
      I <- I+1;
      S <- S-1;
      type <- append(type, 1);
    }
    else {
      #removal
      I <- I-1
      type <- append(type, 2);
    }
  }
  
  # record the final size , i.e. the number of initially susceptibles who 
  # contracted the disease sometime during the epidemic.
  fin_size = sum(type == 1) - 1
  duration = sum(t)
  
  # record the times of events (infections/removals) as well as the type
  #
  #
  res <- list(
    "t" = times, 
    "type" = type, 
    "fin_size" = fin_size, 
    "duration" = duration
    );
  res
}
```

```{r}
map2(
  .x = c(0.9, 2, 4),
  .y = c(1, 1, 1),
  .f = function(.x, .y){
    print(glue::glue("Beta = {.x}, Gamma = {.y}"))
    simSIR.Markov(N = 21, beta = .x, gamma = .y)
  }
)
```

#### SIR Markov alt

```{r}
simSIR.Markov.alternative <- function(N, beta, gamma) {

  # initial number of infectives and susceptibles;
  I <- 1
  S <- N-1;

  # recording time;
  t <- 0;
  times <- c(t);

  # a vector which records the type of event (1=infection, 2=removal)
  type <- c(1);

  while (I > 0) {

    ############################################
    # simulate times to the next possible events
    ############################################
    
    # time to next infection
    if (S > 0) {
      t.next.infection <- t +  rexp(1, (beta/N)*I*S)
    }
    else {
      t.next.infection <- Inf;
    }
    
    # time to next removal    
    t.next.removal <- t + rexp(1, gamma*I)


    # check which of the two events happens first
    if (t.next.infection < t.next.removal) {
      # infection occurs
      I <- I+1;
      S <- S-1;
      type <- append(type, 1);
      times <- append(times, t.next.infection);
      t <- t.next.infection
    }
    else {
      #removal occurs
      I <- I-1
      times <- append(times, t.next.removal);
      type <- append(type, 2);
      t <- t.next.removal
    }
  }
  
  # record the final size , i.e. the number of initially susceptibles who 
  # contracted the disease sometime during the epidemic.
  fin_size = sum(type == 1) - 1
  duration = sum(t)
  
  # record the times of events (infections/removals) as well as the type
  #
  #
  res <- list(
    "t" = times, 
    "type" = type, 
    "fin_size" = fin_size, 
    "duration" = duration
    );
  res
}
```

```{r}
map2(
  .x = c(0.9, 2, 4),
  .y = c(1, 1, 1),
  .f = function(.x, .y){
    print(glue::glue("Beta = {.x}, Gamma = {.y}"))
    simSIR.Markov.alternative(N = 21, beta = .x, gamma = .y)
  }
)
```

#### SIR non-Markov constant

```{r}
simSIR.Non.Markov.constant <- function(N, beta, k) {

  # initial number of infectives and susceptibles;
  I <- 1
  S <- N-1;

  # recording time;
  t <- 0;
  times <- c(t);

  # create a vector containing the removal times of all the current infectives
  r <- k 

  # a vector which records the type of event (1=infection, 2=removal)
  type <- c(1);
  
  # a counter for labelling the individuals
  lambda <- 1;

  # a vector to store the labels
  labels <- c(1);

  while (I > 0) {

    ############################################
    # simulate times to the next possible events
    ############################################
    
    # time to next infection
    if (S > 0) {
      T  <- rexp(1, (beta/N)*I*S)
    }
    else {
      T <- Inf;
    }

    # time to next removal
    R <- min(r, na.rm=TRUE);
    
    # check which of the two events happens first
    if (t + T < R) {
      # infection occurs
      I <- I+1;
      S <- S-1;
      r <- append(r, t + T + k)
      type <- append(type, 1);
      times <- append(times, t + T);

      lambda <- lambda + 1;
      labels <- append(labels, lambda)
      t <- t + T
    }
    else {
      #removal occurs
      I <- I-1
      type <- append(type, 2);
      index.min.r <- which(min(r, na.rm=TRUE)==r)
      r[index.min.r] <- NA
      labels <- append(labels, index.min.r)
      times <- append(times, R);
      t <- R

      # update the vector of 
    }
  }
  
  # record the final size , i.e. the number of initially susceptibles who 
  # contracted the disease sometime during the epidemic.
  fin_size = sum(type == 1) - 1
  duration = sum(t)
  
  # record the times of events (infections/removals) as well as the type
  #
  #
  res <- list(
    "t" = times, 
    "type" = type, 
    "fin_size" = fin_size, 
    "duration" = duration
    );
  res
}
```

```{r}
map(
  .x = c(0.9, 2, 4),
  .f = function(.x){
    print(glue::glue("Beta = {.x}"))
    simSIR.Non.Markov.constant(N = 21, beta = .x, k = 1)
  }
)
```

#### SIR non-Markov Gamma

```{r}
simSIR.Non.Markov.gamma <- function(N, beta, gamma, delta) {

  # initial number of infectives and susceptibles;
  I <- 1
  S <- N-1;

  # recording time;
  t <- 0;
  times <- c(t);

  # create a vector containing the removal times of all the current infectives.
  k <- rgamma(1, gamma, delta)
  r <- k 

  # a vector which records the type of event (1=infection, 2=removal)
  type <- c(1);

  # a counter for labelling the individuals
  lambda <- 1;
  
  # a vector to store the labels
  labels <- c(1);

  while (I > 0) {

    ############################################
    # simulate times to the next possible events
    ############################################
    
    # time to next infection
    if (S > 0) {
      T  <- rexp(1, (beta/N)*I*S)
    }
    else {
      T <- Inf;
    }

    # time to next removal
    R <- min(r, na.rm=TRUE);
    
    # check which of the two events happens first
    if (t + T < R) {
      # infection occurs
      I <- I+1;
      S <- S-1;
      k <- rgamma(1, gamma, delta)
      r <- append(r, t + T + k)

      lambda <- lambda + 1;
      labels <- append(labels, lambda)
      type <- append(type, 1);
      times <- append(times, t + T);
      t <- t + T
    }
    else {
      #removal occurs
      I <- I-1
      type <- append(type, 2);
      index.min.r <- which(min(r, na.rm=TRUE)==r)
      r[index.min.r] <- NA
      labels <- append(labels, index.min.r)
      times <- append(times, R);
      t <- R      
    }
  }
  
  # record the final size , i.e. the number of initially susceptibles who 
  # contracted the disease sometime during the epidemic.
  fin_size = sum(type == 1) - 1
  duration = sum(t)
  
  # record the times of events (infections/removals) as well as the type
  #
  #
  res <- list(
    "t" = times, 
    "type" = type, 
    "fin_size" = fin_size, 
    "duration" = duration
    );
  res
}
```

```{r}
pmap(
  .l = list(
    beta = c(0.9, 2, 4),
    gamma = c(1, 1, 1),
    delta = c(1, 1, 1)
  ),
  .f = function(beta, gamma, delta){
    print(glue::glue("Beta = {beta}, Gamma = {gamma}, Delta = {delta}"))
    simSIR.Non.Markov.gamma(N = 21, beta = beta, gamma = gamma, delta = delta)
  }
)
```

## Exercise 4

### Question

Derive a simulation-based estimate of the distribution of the *final size* of a
Markovian SIR model for different values of R0, e.g. R0=0.9, R0=1.5 and R0=4.
Furthermore, do the same for the non-Markovian models, e.g. for a constant and a
Gamma infectious period. **Hint**: You may find it useful to write a loop which
will iterate the following steps for a number of times:

1.  Simulate a realisation from the epidemic model;
2.  Store the final size
3.  At the end you should have a collection of *final sizes* for which then you
    can plot a histogram as your estimate of the true distribution of the final
    size.

### Answer

#### Set up functions

We can simulate once and plot the output, but let's write a function so that we
can run as many simulations as we'd like, and plot all the values obtained.
Exercise 5 asks us to rerun this process for duration instead of final size, so
let's make sure we capture the duration as part of this function to avoid
unnecessary duplication.

```{r, warning=FALSE, message=FALSE}
library(tidyverse)
theme_set(theme_minimal())
```

```{r}
SIR_model_reps <- function(reps, r0, N, beta, constant = FALSE, ..., model, combine_lists = FALSE){
  
  # Run a number of simulations
  list_of_tibbles <- pmap(
    .l = list(reps),
    .f = function(reps){
      
      # Create the table of final size values for each R0 (within a single 
      # simulation)
      pmap_dfr(
        .l = list(r0 = r0),
        .f = function(r0){
          rep <- reps
          model <- model
          
          if (isFALSE(constant)){
            if (hasArg(delta)){
            gamma <- beta / r0
            }
            
            gamma <- beta / r0
            
            #Can't input model as an argument to map/functions in general, as it
            #is a function itself, so instead need to use rlang::exec() to
            #execute it!
            model_output <- rlang::exec(
              "model",
              N = N, beta = beta, gamma = gamma, ...
              )
            
            # Create a dataframe of the important 
            tibble(
              id = rep,
              R_0 = r0,
              beta = beta,
              gamma = gamma,
              fin_size = model_output$fin_size,
              duration = model_output$duration
            )
          
          } else {
            k <- r0 / beta
            
            # Can't input model as an argument to map/functions in general, as it
            # is a function itself, so instead need to use rlang::exec() to 
            # execute it!
            model_output <- rlang::exec(
              "model",
              N = N, beta = beta, k = k
              )
            
            # Create a dataframe of the important 
            tibble(
              id = rep,
              R_0 = r0,
              beta = beta,
              k = k,
              fin_size = model_output$fin_size,
              duration = model_output$duration
            )
          }
        
        })
    })
  
  if (combine_lists == TRUE){
    bind_rows(list_of_tibbles, .id = "id")
  }

}
```

#### SIR Markov alt

```{r}
SIR_Markov_alt_reps <- SIR_model_reps(
  reps = 1:10,
  r0 = seq(1, 10, 0.1),
  N = 100,
  beta = 1,
  constant = FALSE,
  model = simSIR.Markov.alternative,
  combine_lists = TRUE
)
```

```{r}
SIR_Markov_alt_reps %>% 
  mutate(id = as.factor(as.numeric(id))) %>% 
  ggplot(aes(x = R_0, y = fin_size)) +
  geom_point(aes(color = id), alpha = 0.4) +
  geom_smooth() +
  theme(legend.position = "none") +
  hrbrthemes::scale_colour_ipsum()
```

#### SIR non-Markov constant

```{r}
SIR_non_Markov_const_reps <- SIR_model_reps(
  reps = 1:10,
  r0 = seq(1, 10, 0.1),
  N = 100,
  beta = 1,
  constant = TRUE,
  model = simSIR.Non.Markov.constant,
  combine_lists = TRUE
)
```

```{r}
SIR_non_Markov_const_reps %>% 
  mutate(id = as.factor(as.numeric(id))) %>% 
  ggplot(aes(x = R_0, y = fin_size)) +
  geom_point(aes(color = id), alpha = 0.4) +
  geom_smooth() +
  theme(legend.position = "none") +
  hrbrthemes::scale_colour_ipsum()
```

#### SIR non-Markov Gamma

**This isn't correct:** need to figure out how to calculate $R_0$ when infection
times include a draw from a Gamma distribution i.e. have the parameter `delta`

```{r}
SIR_non_Markov_gamma_reps <- SIR_model_reps(
  reps = 1:10,
  r0 = seq(1, 10, 0.1),
  N = 100,
  beta = 5,
  model = simSIR.Non.Markov.gamma,
  delta = 0.1,
  combine_lists = TRUE
)
```

```{r}
SIR_non_Markov_gamma_reps %>% 
  mutate(id = as.factor(as.numeric(id))) %>% 
  ggplot(aes(x = R_0, y = fin_size)) +
  geom_point(aes(color = id), alpha = 0.4) +
  geom_smooth() +
  theme(legend.position = "none") +
  hrbrthemes::scale_colour_ipsum()
```

## Exercise 5

### Question

Repeat the above exercise but derive, by simulation, the distribution of the
*duration* of the epidemic instead of the *final size*.

### Answer

As we set up our function in exercise 4 to capture both final size and duration,
we don't need to calculate anything - just create the plots.

#### SIR Markov alt

```{r}
SIR_Markov_alt_reps %>% 
  mutate(id = as.factor(as.numeric(id))) %>% 
  ggplot(aes(x = R_0, y = duration)) +
  geom_point(aes(color = id), alpha = 0.4) +
  geom_smooth() +
  theme(legend.position = "none") +
  hrbrthemes::scale_colour_ipsum()
```

#### SIR non-Markov constant

```{r}
SIR_non_Markov_const_reps %>% 
  mutate(id = as.factor(as.numeric(id))) %>% 
  ggplot(aes(x = R_0, y = duration)) +
  geom_point(aes(color = id), alpha = 0.4) +
  geom_smooth() +
  theme(legend.position = "none") +
  hrbrthemes::scale_colour_ipsum()
```

#### SIR non-Markov Gamma

```{r}
SIR_non_Markov_gamma_reps %>% 
  mutate(id = as.factor(as.numeric(id))) %>% 
  ggplot(aes(x = R_0, y = duration)) +
  geom_point(aes(color = id), alpha = 0.4) +
  geom_smooth() +
  theme(legend.position = "none") +
  hrbrthemes::scale_colour_ipsum()
```

## Exercise 6

### Question

Write a function in R to simulate from a non-Markovian stochastic epidemic model
where the infectious period is assumed to follow a Weibull distribution.
**Hint**: The probability density function (pdf) of the Weibull distribution is
as follows:

$$
f(x) = \frac{a}{b} \frac{x}{b}^{(a-1)} \exp(‚àí(x/b)a), x>0,a>0,b>0
$$

Type `?Weibull` to find out how to simulate from a Weibull distribution.

### Answer

Let's first remind ourselves what a Weibull distribution looks like

```{r}
cross_df(
  list(
    shape = seq(1, 2.5, 0.5),
    scale = seq(1, 2.5, 0.5)
  )) %>% 
  pmap_df(
    .f = function(shape, scale){
      
      pmap_df(
        .l = list(x = seq(0.01, 5, 0.01)),
        .f = function(x){
         tibble(
           shape = shape,
           scale = scale,
           x = x,
           dens = dweibull(x, shape, scale)
          )
        }
      )
      
    }
  ) %>% 
  ggplot(aes(x, dens, color = factor(scale))) +
  geom_line() +
  facet_grid(.~shape, labeller = label_both) +
  labs(color = "Scale")
```


```{r}
simSIR.Non.Markov.weibull <- function(N, beta, gamma, delta) {

  # initial number of infectives and susceptibles;
  I <- 1
  S <- N-1;

  # recording time;
  t <- 0;
  times <- c(t);

  # create a vector containing the removal times of all the current infectives.
  k <- rweibull(1, gamma, delta)
  r <- k 

  # a vector which records the type of event (1=infection, 2=removal)
  type <- c(1);

  # a counter for labelling the individuals
  lambda <- 1;
  
  # a vector to store the labels
  labels <- c(1);

  while (I > 0) {

    ############################################
    # simulate times to the next possible events
    ############################################
    
    # time to next infection
    if (S > 0) {
      T  <- rexp(1, (beta/N)*I*S)
    }
    else {
      T <- Inf;
    }

    # time to next removal
    R <- min(r, na.rm=TRUE);
    
    # check which of the two events happens first
    if (t + T < R) {
      # infection occurs
      I <- I+1;
      S <- S-1;
      k <- rgamma(1, gamma, delta)
      r <- append(r, t + T + k)

      lambda <- lambda + 1;
      labels <- append(labels, lambda)
      type <- append(type, 1);
      times <- append(times, t + T);
      t <- t + T
    }
    else {
      #removal occurs
      I <- I-1
      type <- append(type, 2);
      index.min.r <- which(min(r, na.rm=TRUE)==r)
      r[index.min.r] <- NA
      labels <- append(labels, index.min.r)
      times <- append(times, R);
      t <- R      
    }
  }
  
  # record the final size , i.e. the number of initially susceptlbles who contracted the disease sometime during the epidemic.
  #
  #
  
  # record the times of events (infections/removals) as well as the type
  #
  #
  res <- list("t"=times, "type"=type, "labels"=labels);
  res
}
```

## Exercise 7

### Question

Write a function to simulate from an epidemic model which involves a fixed
latent period, i.e. write a function to simulate from a stochastic SEIR model.

### Answer
